<!DOCTYPE html>
<html>

<head>
  
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>写 CUDA 的一些小 Trick | wu-kan</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="写 CUDA 的一些小 Trick" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The art of doing more with less." />
<meta property="og:description" content="The art of doing more with less." />
<link rel="canonical" href="http://localhost:4000/_posts/2020-03-24-%E5%86%99-CUDA-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F-Trick/" />
<meta property="og:url" content="http://localhost:4000/_posts/2020-03-24-%E5%86%99-CUDA-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F-Trick/" />
<meta property="og:site_name" content="wu-kan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-24T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/_posts/2020-03-24-%E5%86%99-CUDA-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F-Trick/","headline":"写 CUDA 的一些小 Trick","dateModified":"2020-03-24T00:00:00+08:00","datePublished":"2020-03-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/_posts/2020-03-24-%E5%86%99-CUDA-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F-Trick/"},"description":"The art of doing more with less.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
  
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1"
/>
<meta
  http-equiv="content-type"
  content="text/html; charset=utf-8"
/>
<link
  rel="alternate"
  href="/feed.xml"
  title="RSS"
  type="application/rss+xml"
/>

  
  <link
  rel="apple-touch-icon-precomposed"
  href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320"
/>
<link
  rel="shortcut
  icon"
  href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css"
/>
<script
  async="async"
  src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js"
  onload='
      let pio_container = document.createElement("div");
      pio_container.classList.add("pio-container");
      pio_container.classList.add("right");
      pio_container.style.bottom = "-2rem";
      pio_container.style.zIndex = "1";
      document.body.insertAdjacentElement("beforeend", pio_container);
      let pio_action = document.createElement("div");
      pio_action.classList.add("pio-action");
      pio_container.insertAdjacentElement("beforeend", pio_action);
      let pio_canvas = document.createElement("canvas");
      pio_canvas.id = "pio";
      pio_canvas.style.width = "14rem";
      pio_canvas.width = "600";
      pio_canvas.height = "800";
      pio_container.insertAdjacentElement("beforeend", pio_canvas);
      let pio = new Paul_Pio({
        "mode": "fixed",
        "hidden": true,
        "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }",
        "content": {
          "link": ["https://jekyll-theme-WuK.wu-kan.cn"],
          "skin": ["要换成我的朋友吗？", "让她放个假吧~"],
          "hidden": true,
          "custom": [{
            "selector": "a",
            "type": "link",
          }, {
            "selector": ".sidebar-toggle",
            "text": "打开侧边栏叭~"
          }, {
            "selector": ".effect-info",
            "text": "哇，你发现了什么！"
          }, {
            "selector": "#sidebar-search-input",
            "text": "想搜索什么呢？很多干货哦！"
          }, {
            "selector": "#toc",
            "text": "这是目录~"
          }, {
            "selector": ".page-title",
            "text": "这是标题~"
          }, {
            "selector": ".v",
            "text": "评论没有审核，要对自己的发言负责哦~"
          }]
        },
        "model": [
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"]
      });'
></script>

  
  <script
  src='https://zz.bdstatic.com/linksubmit/push.js'
  async="async"
></script>

  
  <script
  async="async"
  src="https://www.googletagmanager.com/gtag/js?id=UA-163543967-1"
  onload="
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-163543967-1');"
></script>

  
  <style>
  .wrap {
    transition-property: all;
    transition-duration: .3s;
    transition-timing-function: ease-in-out;
    min-height: 100%;
    display: inline-block;
    background-size: 100% auto;
    background-position: 0% 0%;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp);
  }
  @media (min-aspect-ratio: 2400/1850) {
    .wrap {
      background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp);
    }
  }
  .sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    width: calc(100% - 14rem);
    background-size: calc(100% - 14rem) auto;
    left: 14rem;
  }
  .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    left: 0;
  }
</style>

  
  <style>
  html,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  .sidebar {
    font-family: PingFang SC, Menlo, Monaco, "Courier New", Microsoft JhengHei, monospace;
  }
</style>

  
  <style>
  img {
    display: inline-block;
    margin: 0;
  }
</style>

  
  <style>
  ::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }
  ::-webkit-scrollbar-thumb {
    background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%);
  }
</style>

  
  <style>
  ::selection {
    color: White;
    background: Black;
  }
</style>

  
</head>

<body
  class="theme-base-07 layout-reverse sidebar-overlay">
  
  
  
  <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
  <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"
     />
  <!-- Toggleable sidebar -->
  <div class="sidebar" id="sidebar">
    
    <div class="sidebar-item">
      <div class="effect effect-right_to_left">
        <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" />
        <div class="effect-info">
          SYSU超算17级在读<br/>
永远喜欢水野爱<br/>
田宫例四驱车<br/>
ASC<br/>
<a href="mailto:i@wu-kan.cn">
  <i class="fas fa-envelope"></i>
</a>
<a href="https://github.com/wu-kan">
  <i class="fab fa-github"></i>
</a>
<a href="https://codeforces.com/profile/WuK">
  <i class="fas fa-chart-bar"></i>
</a>
<a href="https://vjudge.net/user/WuK">
  <i class="fas fa-smile"></i>
</a>
<a href="https://www.zhihu.com/people/wu.kan/activities">
  <i class="fab fa-zhihu"></i>
</a>
<iframe
  src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32"
  width=100%
  height=52
  frameborder="no"
  border="0"
  marginwidth="0"
  marginheight="0"
></iframe>

        </div>
      </div>
    </div>
    
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item" href="/">
        <i class="fas fa-home fa-fw"></i> 首页
      </a>
      
      <a class="sidebar-nav-item" href="/comments/">
        <i class="fas fa-comments fa-fw"></i> 留言
      </a>
      
      <a class="sidebar-nav-item" href="/tags/">
        <i class="fas fa-tags fa-fw"></i> 标签
      </a>
      
      <a class="sidebar-nav-item" href="/archive/">
        <i class="fas fa-archive fa-fw"></i> 归档
      </a>
      
      <a class="sidebar-nav-item" href="/merger/">
        <i class="fas fa-coffee fa-fw"></i> 打赏
      </a>
      
    </nav>
    <div class="sidebar-item">
      
      <div>
        <style>
  #sidebar-search-input {
    background: none;
    border: none;
    color: White;
    width: 100%;
  }
  #sidebar-search-results-container {
    overflow: auto auto;
    max-height: 50vh;
  }
</style>
<input
  id="sidebar-search-input"
  placeholder="搜索博文"
/>
<ol
  id="sidebar-search-results-container"
></ol>
<script
  src='https://cdn.jsdelivr.net/npm/simple-jekyll-search/dest/simple-jekyll-search.min.js'
  async='async'
  onload='
    SimpleJekyllSearch({
      json: "/assets/simple-jekyll-search/search.json",
      searchInput: document.getElementById("sidebar-search-input"),
      resultsContainer: document.getElementById("sidebar-search-results-container"),
      searchResultTemplate: `<li><a href="{url}">{title}</a></li>`,
      limit: 999,
      fuzzy: true
    })'
></script>

      </div>
      
      
      <style>
  .sidebar-checkbox {
    display: none;
  }
  .sidebar-toggle {
    position: fixed;
  }
</style>

      
      <style>
  .effect {
    margin: 1rem;
    perspective: 900px;
  }
  .effect-info {
    text-align: center;
    backface-visibility: hidden;
    position: absolute;
    top: 0;
    transform-style: preserve-3d;
  }
  .effect-img {
    z-index: 11;
    width: 100%;
    height: 100%;
    position: relative;
    transition: all 0.5s ease-in-out;
  }
  .effect-img:before {
    position: absolute;
    display: block;
  }
  .effect-right_to_left .effect-img {
    transform-origin: 0% 50%;
  }
  .effect-right_to_left:hover .effect-img {
    transform: rotate3d(0, 1, 0, -180deg);
  }
</style>

      
      <style>
  #toc {
    overflow: auto auto;
    max-height:50vh;
  }
</style>
<aside id="toc">
  目录
</aside>
<script
  defer='defer'
  src='https://cdn.jsdelivr.net/npm/html-contents/html-contents.min.js'
  onload="htmlContents('#toc', {listType: 'o', filter: function(arr) {return !arr.matches('.masthead-title')}})"
></script>

      
      <div>
  <i class="fas fa-cog fa-spin fa-fw"></i>
  <span id="run_time_day">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>天
  <span id="run_time_hour">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>时
  <span id="run_time_minute">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>分
  <span id="run_time_second">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>秒
  <script>
    setInterval(function (BirthDay) {
      function setzero(i) {
        if (i < 10) return "0" + i;
        return i;
      }
      BirthDay = new Date(BirthDay);
      today = new Date();
      timeold = (today.getTime() - BirthDay.getTime());
      sectimeold = timeold / 1000;
      secondsold = Math.floor(sectimeold);
      msPerDay = 24 * 60 * 60 * 1000;
      e_daysold = timeold / msPerDay;
      daysold = Math.floor(e_daysold);
      e_hrsold = (e_daysold - daysold) * 24;
      hrsold = Math.floor(e_hrsold);
      e_minsold = (e_hrsold - hrsold) * 60;
      minsold = Math.floor((e_hrsold - hrsold) * 60);
      seconds = Math.floor((e_minsold - minsold) * 60);
      document.getElementById("run_time_day").innerHTML = daysold;
      document.getElementById("run_time_hour").innerHTML = setzero(hrsold);
      document.getElementById("run_time_minute").innerHTML = setzero(minsold);
      document.getElementById("run_time_second").innerHTML = setzero(seconds);
    }, 1000, "10/04/2017 11:03:56") // 这是我第一篇CSDN博客的时间
  </script>
</div>

      
      <div>
  <div>
    <i class="fas fa-eye fa-fw"></i>
    <span id="busuanzi_value_page_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>次
  </div>
  <div>
    <i class="fas fa-paw fa-fw"></i>
    <span id="busuanzi_value_site_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>枚
  </div>
  <div>
    <i class="fas fa-user-friends fa-fw"></i>
    <span id="busuanzi_value_site_uv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>人
  </div>
  <script
    src='https://cdn.jsdelivr.net/npm/busuanzi'
    async='async'
  ></script>
</div>

      
      <div>
  <i class="fas fa-copyright fa-fw"></i>
  2017-2020 WuK
</div>

      
      <div>
  <i class="fas fa-thumbs-up fa-fw"></i>
  <a href="https://jekyll-theme-WuK.wu-kan.cn">
    jekyll-theme-WuK
  </a>
</div>

      
      <div>
  <i class="fas fa-info-circle fa-fw"></i>
  <a href="http://beian.miit.gov.cn">
    粤ICP备20024947号
  </a>
</div>

      
      
    </div>
  </div>
  <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. -->
  
  <div class="wrap">
    <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/npm/reveal.js/css/reveal.min.css,npm/reveal.js/css/theme/serif.min.css"
/>
<style>
  .sidebar {
    line-height: 1.5;
  }
  .reveal .slides {
    text-align: left;
  }
</style>
<script
  defer="defer"
  src="https://cdn.jsdelivr.net/npm/reveal.js/js/reveal.min.js"
  onload="
  document.getElementsByClassName('wrap')[0].classList.add('reveal');
  let path = 'https:\/\/cdn.jsdelivr.net/npm/reveal.js/';
  Reveal.initialize({
    height: '100%',
    hash: true,
    mouseWheel: true,
    navigationMode: 'linear',
    parallaxBackgroundImage: 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAD8D+JaQAA3AA/uVqAAA=',//这是一张纯白图
    dependencies: [
        { src: path+'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: path+'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: path+'plugin/highlight/highlight.js', async: true },
        { src: path+'plugin/zoom-js/zoom.js', async: true },
        { src: path+'plugin/notes/notes.js', async: true },
        { src: path+'plugin/math/math.js', async: true }
    ]
    });
  "></script>

<div class="slides">
  <section
    data-markdown data-separator='&lt;!-- slide --&gt;'
     data-separator-vertical='&lt;!-- slide vertical=true --&gt;'
     >
    <textarea data-template><p>The art of doing more with less.</p>

<!-- slide -->

<h2 id="blockdim-griddim">blockDim, gridDim</h2>

<!-- slide vertical=true -->

<ul>
  <li>第一次写 cuda 程序的时候，最让我抓狂的就是调用核函数时需要指定的这两个参数。</li>
  <li>在对显卡硬件架构不熟悉的情况下，调参似乎是一种玄学，更是一种哲学。</li>
</ul>

<!-- slide -->

<h3 id="blockdim-的经验值"><code>blockDim</code> 的经验值</h3>

<!-- slide vertical=true -->

<ul>
  <li>由于显卡是按照 STMD（多线程执行同一段代码）方式调度线程的，因此如果要充分利用调度资源，<code>blockDim</code> 最好要是调度最小单位 Warp 的倍数。</li>
  <li>目前主流的显卡单个 Warp 中都是 32 个线程，不排除未来会增加的可能。</li>
  <li>以下是一些 <code>blockDim</code> 的经验值，在大部分情况下都会有较优的表现。</li>
</ul>

<!-- slide vertical=true -->

<pre><code class="language-cpp">dim3 block_dim_1(128); // 用于一维
dim3 block_dim_2(16, 16); // 用于二维
dim3 block_dim_3(8, 8, 8); // 用于三维
dim3 block_dim_v100(1024); // 让v100显卡满载；很多老显卡不支持，最多768个
</code></pre>

<!-- slide -->

<h3 id="cudaoccupancymaxpotentialblocksize"><code>cudaOccupancyMaxPotentialBlockSize</code></h3>

<p>从 CUDA 6.5 开始，提供了一个很有用的函数 <code>cudaOccupancyMaxPotentialBlockSize</code>，该函数定义在 <code>&lt;cuda_runtime.h&gt;</code>，接口及含义见代码中的注释。</p>

<!-- slide vertical=true -->

<pre><code class="language-cpp">template &lt;class T&gt;
cudaError_t __inline__ __host__ CUDART_DEVICE
cudaOccupancyMaxPotentialBlockSize(
    int *minGridSize,           // Suggested min grid size to achieve a full machine launch.
    int *blockSize,             // Suggested block size to achieve maximum occupancy.
    T func,                     // Kernel function.
    size_t dynamicSMemSize = 0, //Size of dynamically allocated shared memory. Of course, it is known at runtime before any kernel launch. The size of the statically allocated shared memory is not needed as it is inferred by the properties of func.
    int blockSizeLimit = 0)     //blockSizeLimit  = Maximum size for each block. In the case of 1D kernels, it can coincide with the number of input elements.
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMem(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit);
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>通过这个接口可以获得让 SM 占用率最大的 <code>blockDim</code> 和对应的最小 <code>gridDim</code></li>
  <li>可以不去关心各种硬件资源的限制写出低开销的调用</li>
  <li>省去了自己调参数的过程</li>
</ul>

<!-- slide -->

<h3 id="cudaoccupancymaxactiveblockspermultiprocessor"><code>cudaOccupancyMaxActiveBlocksPerMultiprocessor</code></h3>

<h2 id="继续减少调度开销">继续减少调度开销</h2>

<!-- slide vertical=true -->

<ul>
  <li>让我们以简单的复数拷贝为例。</li>
  <li>看起来没什么可优化的？</li>
</ul>

<!-- slide vertical=true -->

<pre><code class="language-cpp">void __global__ primitiveZcopy(
	const double *real_in,
	const double *imag_in,
	double *real_out,
	double *imag_out)
{
	const size_t i = blockDim.x * blockIdx.x + threadIdx.x;
	real_out[i] = real_in[i];
	imag_out[i] = imag_in[i];
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>上述核函数中，启动多少线程就拷贝多少数据。</li>
  <li>当启动参数不能恰好表示成两个数的乘积（<code>blockDim.x * gridDim.x</code>）时，需要多次启动核函数
    <ul>
      <li>例如，对<code>19260817</code>个数进行操作</li>
    </ul>
  </li>
  <li>更复杂的例子中可能不能通过多次启动核函数解决问题</li>
</ul>

<!-- slide -->

<h3 id="减少核函数启动次数">减少核函数启动次数</h3>

<!-- slide vertical=true -->

<pre><code class="language-cpp">void __global__ ifZcopy(
	const size_t n,
	const double *real_in,
	const double *imag_in,
	double *real_out,
	double *imag_out)
{
	const size_t i = blockDim.x * blockIdx.x + threadIdx.x;
	if (i &lt; n)
	{
		real_out[i] = real_in[i];
		imag_out[i] = imag_in[i];
	}
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>多启动几个线程就是了
    <ul>
      <li>CUDA 启动少量线程的开销非常小</li>
    </ul>
  </li>
  <li>需要套个<code>if</code>
    <ul>
      <li>有什么缺点？</li>
    </ul>
  </li>
</ul>

<!-- slide vertical=true -->

<ul>
  <li>上述写法至少需要启动与元素数量相等的线程数。
    <ul>
      <li>不能使用<code>cudaOccupancyMaxPotentialBlockSize</code>返回的<code>gridDim</code></li>
      <li>在对大量数据进行操作的时候，线程过多增加调度开销</li>
    </ul>
  </li>
</ul>

<!-- slide -->

<h3 id="将线程和对应的数据解耦">将线程和对应的数据解耦</h3>

<!-- slide vertical=true -->

<pre><code class="language-cpp">void __global__ simpleZcopy(
	const size_t n,
	const double *real_in,
	const double *imag_in,
	double *real_out,
	double *imag_out)
{
	for (size_t i = blockDim.x * blockIdx.x + threadIdx.x;
		 i &lt; n;
		 i += blockDim.x * gridDim.x)
	{
		real_out[i] = real_in[i];
		imag_out[i] = imag_in[i];
	}
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>把<code>if</code>改成<code>for</code>，完美解决问题！
    <ul>
      <li>现在哪怕只启动一个线程，这个核函数也能返回正确结果，降低了依赖</li>
      <li>配合<code>cudaOccupancyMaxPotentialBlockSize</code>效果极佳！</li>
    </ul>
  </li>
  <li>在与使用<code>#pragma omp parallel for</code>并行的代码对比的时候，我们通常会发现，CUDA 版本少了外层的<code>for</code>。
    <ul>
      <li>在这种写法下，爷的青春回来了！</li>
    </ul>
  </li>
  <li>有什么缺点？</li>
</ul>

<!-- slide vertical=true -->

<ul>
  <li>虽然调度开销减少了，但是线程内部频繁<code>for</code>跳转！</li>
</ul>

<!-- slide -->

<h3 id="循环展开">循环展开</h3>

<!-- slide vertical=true -->

<pre><code class="language-cpp">void __global__ simpleZcopy(
	const size_t n,
	const double *real_in,
	const double *imag_in,
	double *real_out,
	double *imag_out)
{
#pragma unroll(32)
	for (size_t i = blockDim.x * blockIdx.x + threadIdx.x;
		 i &lt; n;
		 i += blockDim.x * gridDim.x)
	{
		real_out[i] = real_in[i];
		imag_out[i] = imag_in[i];
	}
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>使用编译推导 <code>#pragma unroll(32)</code> 将循环展开
    <ul>
      <li>奇怪的运行常数减少了！</li>
    </ul>
  </li>
  <li>有什么缺点？</li>
</ul>

<!-- slide vertical=true -->

<ul>
  <li>又多了一个参数需要调！</li>
  <li>需要循环次数是展开次数的倍数</li>
</ul>

<!-- slide -->

<h3 id="使用-template-传递编译期常数">使用 <code>template</code> 传递编译期常数</h3>

<!-- slide vertical=true -->

<pre><code class="language-cpp">template&lt;size_t UNROLL_SIZE&gt;
void __global__ simpleZcopy(
	const size_t n,
	const double *real_in,
	const double *imag_in,
	double *real_out,
	double *imag_out)
{
#pragma unroll(UNROLL_SIZE)
	for (size_t i = blockDim.x * blockIdx.x + threadIdx.x;
		 i &lt; n;
		 i += blockDim.x * gridDim.x)
	{
		real_out[i] = real_in[i];
		imag_out[i] = imag_in[i];
	}
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>cuda 支持 cpp 语法，使用一些 cpp 语法糖！</li>
  <li>将编译期就能确定的常数通过 template 传进去！
    <ul>
      <li>比 <code>#define</code> 更优雅</li>
      <li>方便生成不同展开的版本！</li>
    </ul>
  </li>
  <li>还可以传一些更有用的东西，比如 shared memory 数组的大小！</li>
</ul>

<!-- slide vertical=true -->

<pre><code class="language-cpp">int numThreads, minGridSize, blockSize;
cudaOccupancyMaxPotentialBlockSize(
    &amp;minGridSize,
    &amp;blockSize,
    simpleZcopy&lt;32&gt;);
numThreads = minGridSize * blockSize;
if(n % numThreads == 0 &amp;&amp; n / numThreads % 32 == 0)
	simpleZcopy&lt;32&gt;&lt;&lt;&lt;
		minGridSize,
		blockSize&gt;&gt;&gt;(
		n,
		real_in,
		imag_in,
		real_out,
		imag_out);
else
	simpleZcopy&lt;1&gt;&lt;&lt;&lt;
		minGridSize,
		blockSize&gt;&gt;&gt;(
		n,
		real_in,
		imag_in,
		real_out,
		imag_out);
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>有什么缺点？</li>
</ul>

<!-- slide vertical=true -->

<ul>
  <li>代码太丑了！</li>
  <li>我就想简简单单拷贝一个数据</li>
  <li>有必要这么麻烦吗</li>
</ul>

<!-- slide -->

<h2 id="调库">调库</h2>

<!-- slide vertical=true -->

<ul>
  <li>这种东西应该第一个讲
    <ul>
      <li>调库是一切优化的起点</li>
      <li>调库是一切优化的终点</li>
    </ul>
  </li>
  <li>一些常见好用的高性能库，已经集成在 cuda toolkit 中
    <ul>
      <li><code>thrust</code>中的 <code>thrust::copy</code></li>
      <li><code>cublas_v2</code>中的 <code>cublasDcopy</code></li>
    </ul>
  </li>
  <li>本例中甚至可以用 <code>cudaMemcpy</code></li>
</ul>

<!-- slide -->

<h2 id="减少-bank-conflict">减少 Bank Conflict</h2>

<!-- slide vertical=true -->

<ul>
  <li>这是一个非常简单的分块矩阵乘法$A\times B =C$</li>
  <li>为了访存对齐，$A$按照列优先的顺序存储</li>
</ul>

<!-- slide vertical=true -->

<pre><code class="language-cpp">template &lt;size_t BLOCK_SIZE&gt;
void __global__ simpleMatMatMul(
	const float *Ac,
	const float *B,
	float *C,
	const size_t m,
	const size_t n,
	const size_t p)
{
	const size_t
		r = blockIdx.y * blockDim.y + threadIdx.y,
		c = blockIdx.x * blockDim.x + threadIdx.x;
	float res = 0;
	for (size_t t = 0; t &lt; n; t += BLOCK_SIZE)
	{
		float __shared__
			sAc[BLOCK_SIZE][BLOCK_SIZE],
			sB[BLOCK_SIZE][BLOCK_SIZE];
		__syncthreads();
		sAc[threadIdx.y][threadIdx.x] = r &lt; m &amp;&amp; t + threadIdx.x &lt; n ? Ac[(t + threadIdx.x) * m + r] : 0;
		sB[threadIdx.x][threadIdx.y] = c &lt; p &amp;&amp; t + threadIdx.y &lt; n ? B[(t + threadIdx.y) * p + c] : 0;
		__syncthreads();
		for (size_t i = 0; i &lt; blockDim.x; ++i)
			res += sAc[i][threadIdx.y] * sB[i][threadIdx.x];
	}
	if (r &lt; m &amp;&amp; c &lt; p)
		C[r * p + c] = res;
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>有什么缺点？</li>
</ul>

<!-- slide vertical=true -->

<ul>
  <li>GPU 共享内存是基于存储体切换的架构（bank-switched-architecture）。
    <ul>
      <li>在 Femi，Kepler，Maxwell 架构的设备上有 32 个存储体（也就是常说的共享内存分成 32 个 bank），而在 G200 与 G80 的硬件上只有 16 个存储体。</li>
      <li>每个存储体（bank）每个周期只能指向一次操作（一个 32bit 的整数或者一个单精度的浮点型数据），一次读或者一次写，也就是说每个存储体（bank）的带宽为 每周期 32bit。</li>
    </ul>
  </li>
  <li>BLOCK_SIZE 通常是 32 的倍数，同一列的线程访问对应的 Share Memory 访问同一个 bank 的不同地址，发生大量 bank conflict！</li>
</ul>

<!-- slide vertical=true -->

<pre><code class="language-cpp">template &lt;size_t BLOCK_SIZE&gt;
void __global__ naiveMatMatMul(
	const float *Ac,
	const float *B,
	float *C,
	const size_t m,
	const size_t n,
	const size_t p)
{
	const size_t
		r = blockIdx.y * blockDim.y + threadIdx.y,
		c = blockIdx.x * blockDim.x + threadIdx.x;
	float res = 0;
	for (size_t t = 0; t &lt; n; t += BLOCK_SIZE)
	{
		float __shared__
			sAc[BLOCK_SIZE][BLOCK_SIZE | 1],
			sB[BLOCK_SIZE][BLOCK_SIZE | 1];
		__syncthreads();
		sAc[threadIdx.y][threadIdx.x] = r &lt; m &amp;&amp; t + threadIdx.x &lt; n ? Ac[(t + threadIdx.x) * m + r] : 0;
		sB[threadIdx.x][threadIdx.y] = c &lt; p &amp;&amp; t + threadIdx.y &lt; n ? B[(t + threadIdx.y) * p + c] : 0;
		__syncthreads();
		for (size_t i = 0; i &lt; blockDim.x; ++i)
			res += sAc[i][threadIdx.y] * sB[i][threadIdx.x];
	}
	if (r &lt; m &amp;&amp; c &lt; p)
		C[r * p + c] = res;
}
</code></pre>

<!-- slide vertical=true -->

<ul>
  <li>Shared Memory 二维数组每一行增加一个偏移位，解决问题！</li>
</ul>
</textarea>
  </section>
</div>
  </div>
  
  <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  
</body>

</html>